# jsp04

jsp 프로젝트의 작업 순서

0. 요청설계 하기

1. 뷰 만들기

2. 뷰를 띄워줄 컨트롤러 작성하기

3. 질의명령 작성하기

4. DAO 함수 작성하기

5. 컨트롤러에서 받아서 처리하기

----------------------------------------------------------

MVC 패턴
==> WEB 문서를 만드는 발전된 기술의 하나
	중간에 WAS(Web Application Server) 서버를 이용해서 분산 처리하는 기술
	
	JSP 문서가 실행되는 순서
	
		1. 서버는 클라이언트의 요청을 분석해서 해당 문서를 실행하고
			(디스패치 시킨다)
		2. JSP는 뭔가를 실행해서 데이터를 생산하고 (데이터를 처리하고)
		3. 클라이언트에 응답하는 문서를 작성함
		4. 이 문서로 응답함
		
	이들 과정을 서버 혼자 담당함
	(따라서 중간에 스레드를 자동적으로 처리해서 
		여러 클라이언트를 동시에 응답하도록 시스템 자체가 만들어져있음)
		
	따라서 접속율이 높으면 서버가 다운되는 현상이 발생할 수 있음
	이 문제를 해결하기 위해서 서버의 크기가 점점 커지는 현상이 생겨남
	요새는 개인적인 서버를 운영하는 경우도 많아졌고
	그 사람들이 서버를 완벽하게 구축할 수 없는 경우가 발생
	
	이처럼 작은 서버가 담당할 수 있는 프로그램 기법이 필요했고
	이것을 해결하기 위해서 나온 기법이 분산시스템
	이 분산시스템의 하나로 제시된 방법이 MVC 패턴
	
참고 ]

	컴퓨터가 뭔가 프로그램을 실행하면
	그 프로그램에 그 컴퓨터가 가진 모든 자원을 제공하는 것이 아님
	서버 역시 프로그램의 일종
	따라서 대형컴퓨터를 사용한다고 해서
	서버가 그 대형컴퓨터의 자원을 100% 사용할 수 있는 것이 아님
	
	분산시스템이 필요한 이유는
	여러개의 프로그램을 동시에 실행해서 각각의 일을 전담하게 함으로써
	시스템의 자원을 사용하는 비율을 늘리고
	그 프로그램이 하는 일은 줄어들게 됨
	
	따라서
		전체적으로 각각의 프로그램이 부하를 줄이면서
		문제를 해결할 수 있게 됨
	
참고 ]
	
	Model
	==> 생산된 데이터를 관리하는 기능 담당 또는 데이터 자체를 이야기하기도 함
		(컨트롤러와 뷰 사이에 데이터를 주고 받는 기능 포함)
		
	View
	==> 생성된 데이터를 이용해서 응답 문서를 작성하는 기능 담당
	
	Controller
	==> 클라이언트의 요청에 따라서 문제를 해결하는 기능 담당
		(데이터를 생산하는 기능 담당)
		
		1. Dispatch 컨트롤러
			==> 서버를 대신해서 요청을 분석하여
				실행 문서를 선택하도록 하는 컨트롤러
				==> 이 부분이 바로 서블릿으로 제작하게 될 부분
				
		2. 일반 컨트롤러
			==> 우리가 제작했던 일반 자바 클래스로 제작하면 됨
			
		3. 뷰
			==> 이것은 일반 JSP 문서로 작성하면 됨
				왜냐하면 뷰는 응답 문서를 만드는 것이고
				응답 문서를 HTML로 만들어야 하므로
				HTML 문서로 만들 수 있는 유일한 언어는 JSP이기 때문
				
----------------------------------------------------------

Servlet(서블릿)
==> JSP 파일로 문서를 작성하더라도 자바 class로 변환되어서 실행되어짐
	이처럼 JSP 문서가 변환된 클래스를 우리는 서블릿 클래스라고 함
	
	따라서 만약 우리가 서블릿 클래스를 직접 만들 수 있다면
	서버 입장에서는 JSP를 서블릿 클래스로 변환하는 작업을 줄일 수 있게 되고
	그러면 처리 속도가 좀 더 빨라질 수 있음
	
참고 ]

	Web 페이지를 만드는 기술의 변천사
	
		Model1
		==> JSP 문서를 만들어서 문서 내에서 처리하는 기술
		
		Model2
		==> MVC 패턴을 이용해서 처리하는 기술
		
서블릿 클래스를 만드는 방법

	1. HttpServlet 클래스를 상속 받은 클래스를 제작하기
	
	2. 이 안에 4개의 함수를 오버라이드하기
	
		1) public void init() throws ServletException {}
		==> init 시점에서 실행되는 함수
			따라서 이 함수는 우리가 배운 자바 생성자 함수에 해당한다고 생각하면 됨
			
		2) protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {}
		3) protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {}
			==> 2) 3)은 이 모든 service 시점에서 실행되는 함수
				따라서 실제로 클라이언트에게 응답하는 내용은 이 안에서 작성하면 됨
				
			참고 ]
				
				만약 2) 3) 함수 외에 service 함수가 존재하면
				2) 3) 함수는 실행하지 않고 service 함수가 실행됨
				
		4) public void destroy()
			==> destroy 시점에서 실행되는 함수
				따라서 이 부분에서는 그 클래스가 주로 사용하던 자원을 제거하거나 반환해주는 목적으로 사용
	
	3. 각각의 함수에 역할을 코딩하기
		
		참고 ]
		
			서블릿의 생존주기
			
				init			서블릿 클래스가 가장 처음 만들어지는 시점
				 |				(누군가 가장 처음 이 클래스를 요청한 경우 딱 한번만 실행)
				 |	
				service			누군가 이 클래스를 요청한 시점
				 |				(요청할 때마다 매번 실행되는 함수)
				 |
				destroy			적당한 시간(서버가 지정한 시간)동안
								요청이 전혀 없는 경우의 시점
								(적당한 시점이 되면 이 클래스는 없어져야 함)
									그 때 실행 됨
									따라서 주로 사용하던 자원을 닫는 목적으로 사용
									
만들어진 서블릿 클래스를 실행하는 방법
==> JSP 문서는 그 문서를 요청하면 실행되지만
	서블릿 클래스는 웹 문서가 아니므로 원칙적으로 요청할 수 없음
	
	*****
	따라서 서블릿 클래스가 실행되도록 요청 등록을 해줘야 함
	
	1. web.xml 파일에 요청등록
		1) 서블릿 등록하기
			==> 만들어진 서블릿 클래스를 톰캣이라는 서버가 사용하도록 등록하는 방법
				
				<servlet>
					<servlet-name>loginAjax</servlet-name>
					<servlet-class>만들어진 서블릿 클래스 경로</servlet-class>
					==> 패키지까지 전체 경로를 정확하게 등록해야 함
				</servlet>
				
		2) 요청 내용과 서블릿을 매핑시킴
			==> 어떤 요청이 오면 위에 만든 서블릿을 실행시킬건지를 등록하는 부분
				
				<servlet-mapping>
					<servlet-name>서블릿이름</servlet-name>
					==> 서블릿이름은 위에서 정의한 서블릿 이름을 사용해야 함
					<url-pattern>패턴정의</url-pattern>
					==> 어떤 요청이 오면 실행할지를 기술
						이 때 *를 이용해서 만능 처리 가능
				</servlet-mapping>
				
	2. 서블릿 클래스에 어노테이션을 이용해서 요청등록하는 방법
				