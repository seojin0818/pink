# jsp03

내장객체의 영역
==> 내장객체를 이용하면 데이터를 보관하고 사용할 수 있음
	즉, 서버 스스로가 필요한 데이터를 보관했다가 사용할 수 있게 됨
	
	물론 자바의 형식으로 변수에 기억해 놓았다가 사용해도 되지만
	==> 자바로 변수를 만들면 거의 지역변수로 만들어지게 되므로 
		같은 지역(문서)에서만 사용할 수 밖에 없는 문제점이 있음
		
	좀 더 다양한 문서에서 데이터를 공유할 수 있는 기능을 제공하고 있음
	
	문제는 내장객체 중 무엇을 이용해서 데이터를 기억했는가에 따라
	그 데이터를 사용할 수 있는 영역이 달라지게 됨
	
	따라서 이것을 우리는 내장객체의 영역이라고 표현함
	
	예 ]
	
		request.setAttribute();
		==> 이렇게 데이터를 기억하면
			이것은 요청이 유지되는 상태에서는 그 데이터를 사용할 수 있음
			
		session.setAttribute();
		==> 이렇게 데이터를 기억하면
			이것은 세션이 유지되는 동안에는 그 데이터를 사용할 수 있음
			
	1) page context
		==> 같은 문서 안에서만 그 데이터를 사용할 수 있음
			<%
				int num = 30000;
			%>
			이렇게 변수를 만들면 service 함수 내에 num이라는 변수가 생기게 되므로 지역변수가 됨
			
			선언자 방식으로
			<%!
				int num = 10;
			%>
			이렇게 만들게 되면
			이 jsp 파일이 클래스로 변환됐을 때
			그 클래스의 멤버 변수로 만들어지게 되므로
			역시 이 페이지에서만 사용할 수 있는 변수가 됨
			
			==> 이것은 거의 사용하지 않음
				왜? 함수 내에서 변수로 기억하는 것과 동일하기 때문에
	
	*****			
	2) request
		==> 같은 요청을 유지한 문서에서 그 데이터를 사용할 수 있음
		
	*****
	3) session
		==> 같은 세션을 유지한 문서에서 그 데이터를 사용할 수 있음
		
	4) application
		==> 같은 서버를 사용하는 문서에서 그 데이터를 사용할 수 있음
			웹 서버는 각각의 클라이언트에게 독립적으로 응답하는 것이 일반적
			즉, 다른 클라이언트의 요청과 상관없이
			그 클라이언트가 요청한 문제점을 해결하는 것이 일반적
			굳이 모든 문서에서 동일한 데이터를 사용할 일은 거의 존재하지 않음
			
	참고 ]
		
		데이터를 입력할 때
			setAttribute("키값", 데이터);
			==> 마치 Map처럼 데이터를 입력하면 됨
				이 때 입력되는 데이터는 모두 Object 타입으로 자동 형변환 됨
				
		데이터를 꺼낼 때
			getAttribute("키값");
			==> 마치 Map에서 데이터를 꺼내는 것처럼 사용하면 됨
				꺼낸 데이터는 원래 형태로 강제 형변환 해줘야 함
			
	주의 ]
	
		parameter는 데이터를 꺼내는 함수는 존재하지만
		데이터를 입력하는 함수는 존재하지 않음
		request.getParameter("키값"); ==> O
		request.setParameter("키값", 데이터); ==> X
		
		parameter는 문자열로 전송되므로
		꺼내면 문자열 데이터가 됨
		따라서 문자열 변수로 받아서 사용해야 하고
		다른 형태로 변환되어야 한다면 강제 형변환 또는 파싱해야 함
		
------------------------------------------------------------------------

액션 태그
==> JSP는 HTML 언어를 기반으로 해서
	필요한 위치에 자바적인 요소를 스크립트하는 방식으로 만들어진 언어
	
	그래서 HTML은 태그를 중심으로 작성을 하고
	자바 요소는 <% %>를 이용해서 처리하므로 조금은 불편함이 있음
	
	자주 사용하는 자바적인 기능을 HTML처럼 태그방식으로 사용할 수 있도록
	만들어놓은 보조적인 명령을 말함
	
	1. forward를 대신하는 액션 태그
		
		형식 1 ]
		
			<jsp: forward	page="대신 응답할 문서경로" />
				또는
			<jsp: forward	page="대신 응답할 문서경로" ></jsp:forward>
				
			==> 단순히 보여줄 페이지만 변경하는 문법
			
		형식 2 ]
			
			<jsp: forward	page="대신 응답할 문서경로">
				<jsp:param name="키값"	value="데이터" scope="???" />
				...
			</jsp: forward>
			
			==> 보여줄 페이지를 변경하면서 부가정보를 알려주는 문법
			
	참고 ]
	
		액션 태그는 XHTML를 기반으로 해서 제작된 태그
		몸체가 있는 태그
			
			<태그이름>
				내용
			</태그이름>
			
		몸체가 없는 태그
		
			<태그이름 속성="속성값" />
			
	***
	2. 다른 문서를 포함시키는 기능을 가진 액션 태그
		(<%@ include file=???" %>)과 같은 역할을 하는 액션 태그
		
		형식 ]
		
			<jsp:include page="합칠 문서 경로" />
			
		주의 ]
		
			<%@ include file="합칠 문서 경로" %>
			==> 먼저 문서의 내용을 합쳐서 클래스로 만들고 컴파일 함
				합쳤을 때 충돌 위험 있음
			
			<jsp:include page="합칠 문서 경로" />
			==> 각각 합칠 문서와 합쳐질 문서를 각각 클래스로 만들어서 실행한 후
				실행결과만 합치게 됨
				따라서 따로 컴파일이 되므로 충돌 염려 없음
				
------------------------------------------------------------------------

JSTL(Java Standard Tag Library)
==> JSP를 제작하다보면 HTML과 자바소스코드가 혼용되어서 만들어짐

	예 ]
	
		<% 자바소스코드 %>
		HTML 태그들...
		<%= 변수 또는 함수 %>
		태그들...
		
	따라서 자바적인 내용을 입력하는 경우 스크립트 릿 방식을 사용해서 입력하게 됨
	==> 이것은 개발자가 뷰 문서를 제작할 때 항상 고민되는 부분
	
	JSTL이란?
	JSP는 HTML(태그를 이용한 문서작업)이 우선되므로
	자바적인 요소 역시 태그 형식으로 사용할 수 있도록 해서
	(그러면 문서를 작성하는 사람이 한가지 형식으로만 만들 수 있게 되므로)
	통일된 방식으로 문서를 만들 수 있도록 만들어놓은 라이브러리
	
	예 ]
	
		스크립트 릿 방식으로 반복해서 태그를 만들 경우
		
		<%
			for(int i = 0 ; i < 10 ; i++){
		%>
			반복되어서 만들어질 태그들
		<%
			}
		%>
		
		태그 라이브러리를 사용해서 만들 경우
		<c:forEach begin="1" end="10" step="1">
			반복되어서 만들어질 태그들
		</c:forEach>
		
		<c:forEach var="data" items="${ARR}">
			태그들...
			${data}
			태그들...
		</c:forEach>
			
JSTL 사용방법

	1. JSTL 라이브러리를 다운 받아서 프로젝트의
		WEB-INF/lib/ 폴더에 붙여넣기
		
		파일 ]
		
			jstl-1.2.jar, jstl-api-1.2.jar
			
		참고 ]
			
			/WEB-INF/lib 폴더는
			작업 중인 프로젝트에서 사용할 외부 라이브러리를 추가해주는 폴더
			
	JSTL의 종류
		*****
		1. Core Tag
			==> 일반적인 자바 명령을 태그로 만들어놓은 라이브러리
			
		2. Formatting Tag
			==> 출력할 때 모양을 지정하기 위한 기능을 태그로 만들어놓은 라이브러리
		
		***	
		3. Function Tag
			==> 자바에서 자주 사용하는 함수를 사용할 수 있도록 만들어놓은 라이브러리
			
		4. SQL Tag
			==> 데이터베이스를 사용할 때 필요한 기능을 태그로 만들어놓은 라이브러리
		
		5. XML Tag
			==> xml 문서 처리를 위한 기능을 태그로 만들어놓은 라이브러리
			
	2. JSTL이 필요한 문서(JSP)에 5가지 중 필요한 라이브러리를 사용할 수 있도록 등록
		==> 이 작업은 모든 JSP 문서에서 매번 해줘야 함
		
		형식 ]
		
			<%@ taglib prefix="???" uri="???" %>
			
			prefix	: 	아무 내용이나 기입해도 상관없음
						이것의 의미는 taglib는 누군가 만들어놓은 태그를 사용하도록 하는 명령
						이 때 자바는 오픈소스이고 아무나 만들 수 있고 배포할 수 있음
						이 때 문제점은
							태그의 이름이 중복될 수 있다는 것
						
						태그를 사용하는 사용자가 각각의 태그를 구분하기 위해 부여한 자신만의 규칙
						
			uri		: 	이 태그 라이브러리를 제공하는 CDN 네트워크 경로
						또는 태그 라이브러리 기능을 제공하는 클래스 이름을 지정하는 부분
				
				제작자 입장
					갑
						<str></str> 기능을 만들어서 배포하는데		
									기능은 문자열로 출력하는 기능이라고 하고
					을
						<str></str>	기능을 만들어서 배포하는데
									기능은 문자열을 기억하는 기능이라고 가정하면
				사용자 입장
					
					갑이 만든 태그는 prefix="a"
					을이 만든 태그는 prefix="b"
					
					<a:str>*********</a:str> ==> 갑이 만든 문자열을 출력하는 기능의 태그
					
					불문율 ]
					
						*****
						1. Core
							<%@ taglib prefix="c"
										uri="http://java.sun.com/jsp/jstl/core" %>
						
						2. Formatting
							<%@ taglib prefix="fmt"
										uri="http://java.sun.com/jsp/jstl/fmt" %>
							
						***			
						3. Function
							<%@ taglib prefix="fn"
										uri="http://java.sun.com/jsp/jstl/functions" %>
										
						4. SQL
							<$@ taglib prefix="sql"
										uri="http://java.sun.com/jsp/jstl/sql" %>
										
						5. XML
							<$@ taglib prefix="x"
										uri="http://java.sun.com/jsp/jstl/xml" %>				
						
------------------------------------------------------------------------

표현언어(표현식, Expression Language: EL)
==> 
	***
	직역하자면 표현언어를 의미
	EL은 JSP 스크립트 태그(<%= %>)를 대신해서
	JSP 값들을 좀 더 편리하게 출력하기 위해 제공되는 언어
	
	표현자 방식으로 데이터를 출력할 때는
	<%= %> 태그를 사용할 경우
	일반 태그 사이에 내용을 출력할 경우
	<, > 사이에 표현식이 표현되기 때문에 겹쳐지므로 문제 발생 가능성
	EL은 이런 단점을 보완하고 간결한 데이터 출력을 위해 제공되는 기능
	
	EL은 변수를 출력하기도 하지만
	연산자와 내장객체도 제공하고 있으므로
	내장객체의 내용도 출력 가능

	형식 ]
	
		${출력할 내용}
	
	의미 ]
		
		출력할 내용을 화면에 출력함
		출력할 내용은 변수, 연산식, 함수 등 모든것이 올 수 있음
		<%= =>로 생각하면 됨
		
	예 ]
	
		컨트롤러에서 req.setAttribute("KEY", "홍길동");
		이라고 뷰에게 넘겨주면 (요청객체에 저장하면)
		<== forward로 뷰만 바꿔치기하고 요청객체는 유지하고 있으므로
		
		뷰에서는
			${KEY}
		로 호출해서 사용하면 됨
		
		중요 ]
		
			EL 객체를 이용해서
			VO를 통째로 뷰에 전달할 수 있음
			만약 컨트롤러에서
				req.setAttribute("DATA", mVO);
				
			뷰에서는 회원번호를 출력할 때는
				${DATA.mno}
			로 VO 안에 만든 변수이름을 기술해서 사용하면 됨
			
			이 때 이 JSP 클래스에서 VO의 변수에 직접 접근하는 것이 아니고
			getXXX() 함수를 자동 호출하게 됨
			
		참고 ]
		
			${데이터}에서 데이터 부분에 바로 사용할 수 있는 것은
			request 객체의 속성과
			session 객체의 속성은 바로 사용할 수 있음
			
			session 객체의 경우
			원칙은
				${sessionScope.키값}
			이지만
				${키값}
			으로 사용할 수 있도록 만들어두었음
			
	내장객체 ]
		
		pageScope
			==> Page 영역에 존재하는 객체를 참조
			
		***
		requestScope
			==> Request 영역에 존재하는 객체를 참조
			
		***
		sessionScope
			==> Session 영역에 존재하는 객체를 참조
			
		applicationScope
			==> Application 영역에 존재하는 객체를 참조
			
		***
		param
			==> 파라미터 값을 출력할 때 사용
			
		**
		paramValues
			==> 파라미터 값을 배열로 꺼낼 때 사용
			
		header
			==> Header 정보를 얻어올 때 사용
			
		headerValues
			==> Header 정보를 배열로 얻어올 때 사용
		
		*
		cookie
			==> 쿠키 객체를 참조할 때 사용
			
		initParam
			==> 컨텍스트의 초기화 파라미터를 의미
			
		pageContext
			==> PageContext 객체를 참조할 때 사용
			
	*****
	EL 객체 중 requestScope와 sessionScope에 기억된 데이터는 소속을 생략해도 무방함
		
2. <c:out>
	==> 표현식과 동일하게 뭔가를 출력하는 기능을 가진 태그
	
	형식 ]
	
		<c:out value="출력할 내용" />
		
	예 ]
	
		컨트롤러에서
			req.setAttribute("NAME", "jennie");
		라고 데이터를 속성에 기억했다면
		
		뷰에서는
			<c:out value="${NAME}" />
		의 형식으로 사용하면 됨
		
	장점 ]
	
		동시에 여러개를 출력할 수 있음
		즉, 스스로가 여러개를 하나의 문자열로 결합해서 출력함
		
		예 ]
		
			<c:out value="${'<tag>, 10'}" />
			==>
				<tag>, 10
				으로 출력
				
	***
	참고 ]
		
		JSTL을 사용할 때
			1. 몸체가 있는 태그
				<시작태그>
					몸체
				</시작태그>
				
			2. 몸체가 없는 태그
				<태그이름	속성="속성값" ... />
				
3. <c:set>
	==> 변수에 데이터를 기억해놓는 기능을 가진 태그
	
		형식 ]
		
			<c:set var="변수이름" value="데이터" />
			
		예 ]
		
			<c:set var="name" value="jennie" />
			==> String name = "jennie";
				의 역할을 하고
				
				사용할 때는
				${name} ==> jennie가 출력
				
		참고 ]
		
			이 때 기억할 데이터는 타입이 무엇이든 상관없음
			대신 따옴표는 반드시 붙여야 함
			
4. <c:remove>
	==> 변수의 데이터를 강제로 삭제하는 기능을 가진 태그
	
		형식 ]
		
			<c:remove var="변수이름" />
		
		형식 ]
		
			<c:remove var="name" />
			
*****
5. <c:if>
	==> 자바의 if문의 기능을 태그로 만든 것
	
		형식 ]
		
			<c:if test="조건식">
				태그 또는 내용
			</c:if>
			
		의미 ]
		
			조건식이 참이면 태그 또는 내용을 화면에 보여주세요
			
		주의 ]
		
			아직은 else나 else if 태그는 아직 만들어지지 않은 상태
			따라서 다중 조건식을 사용해야 한다면
			이 태그를 여러번 조건식을 각각 나열해서 기술해야 함
	
	***		
	참고 ]
	
		JSTL에서는 조건식을 만들 때
		조건 연산자는 자바에서 사용하는 연산자를 사용할 수 있고
		JSTL 연산자를 사용할 수 있음
		
			eq		==
			lt		<
			le		<=
			gt		>
			ge		>=
			ne		!=
			
			and		&&
			or		||
			not		!
			
			empty 	데이터가 비어있느냐???
			
			예 ]
			
				컨트롤러에서
					ArrayList list = dao.getList();
					req.setAttribute("LIST", list);
					
				jsp 페이지에서는
					<c:if test="${empty LIST}" >
						<h2>회원들이 존재하지 않습니다.</h2>
					</c:if>
					
					<c:if test="${not empty LIST}" >
						<c:forEach var="data" items="${LIST}">
							<div class="w3-button w3-blue">${data}</div>
						</c:forEach>
					</c:if>
					
*****
6. <c:choose>
	==> 자바의 switch case와 유사한 기능을 가진
		다중 조건 처리 명령을 위한 태그
		
		형식 ]
			
			<c:choose>
				<c:when test="조건식1">
					처리내용1
				</c:when>
				<c:when test="조건식2">
					처리내용2
				</c:when>
				<c:when test="조건식3">
					처리내용3
				</c:when>
				<c:when test="조건식4">
					처리내용4
				</c:when>
				...
				<c:otherwise>
					처리내용
				</c:otherwise>
			</c:choose>
			
		참고 ]
			
			한개라도 c:when이 맞으면 그것만 처리하고
			c:choose를 종료
			
*******
7. <c:forEach>
	==> 자바의 for 명령을 태그로 만들어놓은 기능
	
	형식 1 ]
	
		<c:forEach var="변수" begin="시작값" end="종료값" step="증감값">
			내용...
			(
				여기서 반복문의 카운터 변수값을 사용할 때는
					${변수}
				의 형식으로 사용하면 됨
			)
		</c:forEach>
		
		예 ]
			
			java에서
				for(int i = 1 ; i < 10 ; i++){
				}
				
			태그라이브러리에서는
				<c:forEach var="i" begin="1" end="9" step="1">
					${i}, 
				</c:forEach>
				
		주의 ]
		
			end 속성값은 "==" 개념이 포함됨
			즉, end 값까지 반복함
			
		참고 ]
		
			step이 1인 경우는 생략해도 무방함
			
	형식 2 ]
		
		<c:forEach var="변수이름" items="${컬렉션 혹은 배열}">
			${변수이름}
		</c:forEach>
		==> 자바의 향상된 for 명령에 해당하는 것으로
			컬렉션이나 배열의 내용을 변수에 한개씩 꺼내서
			기억시켜서 데이터 개수만큼 반복해서 처리함
			
	참고 ]
	
		forEach 태그는 varStatus라는 속성을 사용할 수 있는데
		이 속성은 반복 상태를 기억하는 역할을 담당함
		
		예 ]
		
			<c:forEach var="..." items="???" varStatus="변수">
				varStatus 속성에 기술한 변수에 반복상태가 기억됨
			</c:forEach>
			
		반복상태
		
			current		: 현재 꺼낸 데이터를 기억
			index		: 현재 몇번째 반복인지를 기억(index를 기억, 0부터 카운트)
			count		: 현재 반복 회차를 기억(1부터 카운트) 
			first		: 현재 반복이 첫 반복인지를 true/false로 기억
			last		: 현재 반복이 마지막 반복인지를 true/false로 기억
			begin		: 시작값을 기억
			end			: 종료값을 기억
			step		: 증감값을 기억
			
			==> 사용할 때
				${변수.current} ==> 현재 꺼낸 데이터가 출력
				${변수.count} ==> 현재 반복 회차를 출력
				
8. <c:forTokens>
	==> 하나의 문자열을 지정한 기호로 분리시켜서 반복하는 태그
		자바의 StringTokenizer와 비슷한 역할을 하는 태그
		
		형식 ]
		
			<c:forTokens var="변수" items="데이터" delims="구분자">
			</c:forTokens>
			
		참고 ]
		
			delims 속성은 여러 구분문자를 동시에 사용할 수 있음
			
9. <c:redirect>
	==> 강제로 요청을 변경하는
		response.sendRedirect()에 해당하는 태그
		
		형식 1 ]
		
			<c:redirect url="새로운요청" />
			==> 일반적인 요청, 요청만 바꾸는 기능
			
		형식 2 ]
		
			<c:redirect url="새로운요청">
				<c:param name="키값" value="데이터" />
				<c:param name="키값" value="데이터" />
				...
			</c:redirect>
			==> 요청을 하면서 부가 정보를 동시에 제공하는 형식
			
		참고 ]
			
			이 때 요청은 GET 방식으로 요청을 하게 됨
			
		참고 ]
			
			리다이렉트 될 페이지에서 POST 방식으로 부가 정보를 추가해서 요청하는 방법
			
			1. form 태그 만들기(method, action, name, id를 모두 작성)
			2. form 태그 안에 전달할 데이터가 입력된 input 태그 만들기
				이 때 타입은 hidden이면 됨
			3. javascript에서 body 태그가 완성되면
				위에서 만든 form 태그를 전송함
			
		예 ]
		
			컨트롤러에서 VO를
				req.setAttribute("DATA", mvo);
				
			JSP 문서에서 
			<body>
			<script type="text/javascript">
				$(document).ready(function(){
					$('#frm').submit();
				});
			</script>
				
				<form method="POST" action="리다이렉트 할 주소" name="frm" id="frm">
					<input type="hidden" name="mno" value="${DATA.mno}"> 
					<input type="hidden" name="id" value="${DATA.id}"> 
					<input type="hidden" name="name" value="${DATA.name}"> 
					<input type="hidden" name="ano" value="${DATA.ano}"> 
				</form>
			</body>
		